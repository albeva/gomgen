package gomgen

/*********************************************************
 * File header, imports and db part
 *********************************************************/
const headerTpl = `// Autogenerated by gomgen
package model

import (
	{{range $k, $v := .Imports}}"{{ $k }}"
	{{end}}
)

// object can be scanned. Row, Rows
type scannable interface {
	Scan(...interface{}) error
}

// database connnection
var theDb *sql.DB

// register db object for the models
func Register(db *sql.DB) error {
	theDb = db
	return nil
}
`

/*********************************************************
 * Generate entity struct type with the fields
 *********************************************************/
const entityStructTpl = `
// table {{ .Name }}
type {{ .EntitySingular }} struct {
	{{range $i, $field := .Fields }}{{ $field.Name }} {{ $field.GoType }}
	{{end}}
}
`

/*********************************************************
 * Scan data from the rows object into the entity
 *********************************************************/
const scanEntityTpl = `
// Scan {{.EntitySingular}} from rows object
func (this *{{.EntitySingular}}) scan(rows scannable) error {
	{{range $type, $vars := .Vars}}var {{$vars}} {{$type}}
	{{end}}{{if .Vars}}err := rows.Scan({{ .Params }})
	if err != nil {
		return err
	}{{range $i, $code := .Inits}}
	{{ $code }}{{end}}
	return nil{{ else }}return rows.Scan({{ .Params }}){{ end }}
}
`

/*********************************************************
 * Fetch row(s) from the database
 *********************************************************/
const findEntityTpl = `
// find {{ .EntitySingular }}
func Find{{ .EntitySingular }}(query interface{}, params... interface{}) (*{{ .EntitySingular }}, error) {
	var sql = "SELECT {{ .EscapedName }}.* FROM {{ .EscapedName }}";
	// decode the query part
	{{if .IdentityField}}switch val := query.(type) {
	case int:
		sql += " WHERE {{ .EscapedName }}.{{.IdentityField.EscapedName}} = " + strconv.Itoa(val)
	case string:
		sql += " " + val
	default:
		return nil, errors.New("Unsupported type")
	}{{else}}if val, ok := query.(string); ok {
		sql += " " + val
	} else {
		return nil, errors.New("Unsupported type")
	}{{end}}
	// process
	entity := &{{ .EntitySingular }}{}
	if err := entity.scan(theDb.QueryRow(sql, params...)); err != nil {
		return nil, err
	}
	return entity, nil
}

// find all {{ .EntityPlural }}
func Find{{ .EntityPlural }}(params... interface{}) ([]*{{ .EntitySingular }}, error) {
	sql := "SELECT {{ .EscapedName }}.* FROM {{ .EscapedName }}"
	// first param might be extra sql. Rest are parameters
	if len(params) > 0 {
		value := params[0]
		params = params[1:]
		query, ok := value.(string)
		if !ok {
			errors.New("Not supported query type")
		}
		sql += " " + query
	}
	// execute the query
	rows, err := theDb.Query(sql, params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	// process rows
	var entities []*{{ .EntitySingular }}
	for rows.Next() {
		entity := &{{ .EntitySingular }}{}
		if err := entity.scan(rows); err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}
	return entities, nil
}
`


/*********************************************************
 * Save or insert entity into the database
 *********************************************************/
const entitySaveTpl = `
// Save {{.EntitySingular}}
func (this *{{.EntitySingular}}) Save() error {
	// update or insert?
	if {{ .IdCheck }} {
		sql := "INSERT INTO {{ .EscapedName }} ({{ .InsertCols }}) VALUES ({{ .InsertVals }})"
		result, err := theDb.Exec(sql, {{.InsertParams}})
		if err != nil {
			return err
		}
		lastId, err := result.LastInsertId()
		if err != nil {
			return err
		}
		this.{{ .AutoIncField.Name }} = lastId
	} else {
		sql := "UPDATE {{ .EscapedName }} SET {{ .UpdateVals }} WHERE {{ .Where }}"
		result, err := theDb.Exec(sql, {{.UpdateParams}})
		if err != nil {
			return err
		}
		affected, err := result.RowsAffected();
		if err != nil {
			return err
		} else if affected != 1 {
			return fmt.Errorf("Wrong number of rows affected. Expected 1. Got %d", affected)
		}
	}
	return nil
}
`
