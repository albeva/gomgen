// Autogenerated by gomgen
package model

import (
	"database/sql"
	"errors"
	"fmt"
	"strconv"
	"time"
)

// object can be scanned. Row, Rows
type scannable interface {
	Scan(...interface{}) error
}

// database connnection
var theDb *sql.DB

// register db object for the models
func Register(db *sql.DB) error {
	theDb = db
	return nil
}

// table article
type Article struct {
	Id         int64
	Active     bool
	Title      string
	Content    string
	CreateDate time.Time
	UpdateDate time.Time
	CategoryId int64
}

// Scan Article from rows object
func (this *Article) scan(rows scannable) error {
	var CreateDate, UpdateDate string
	err := rows.Scan(&this.Id, &this.Active, &this.Title, &this.Content, &CreateDate, &UpdateDate, &this.CategoryId)
	if err != nil {
		return err
	}
	this.CreateDate, _ = time.Parse("2006-01-02 15:04:05", CreateDate)
	this.UpdateDate, _ = time.Parse("2006-01-02 15:04:05", UpdateDate)
	return nil
}

// find Article
func FindArticle(query interface{}, params ...interface{}) (*Article, error) {
	var sql = "SELECT `article`.* FROM `article`"
	// decode the query part
	switch val := query.(type) {
	case int:
		sql += " WHERE `article`.`id` = " + strconv.Itoa(val)
	case string:
		sql += " " + val
	default:
		return nil, errors.New("Unsupported type")
	}
	// process
	entity := &Article{}
	if err := entity.scan(theDb.QueryRow(sql, params...)); err != nil {
		return nil, err
	}
	return entity, nil
}

// find all Articles
func FindArticles(params ...interface{}) ([]*Article, error) {
	sql := "SELECT `article`.* FROM `article`"
	// first param might be extra sql. Rest are parameters
	if len(params) > 0 {
		value := params[0]
		params = params[1:]
		query, ok := value.(string)
		if !ok {
			errors.New("Not supported query type")
		}
		sql += " " + query
	}
	// execute the query
	rows, err := theDb.Query(sql, params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	// process rows
	var entities []*Article
	for rows.Next() {
		entity := &Article{}
		if err := entity.scan(rows); err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}
	return entities, nil
}

// Save Article
func (this *Article) Save() error {
	// update or insert?
	if this.Id == 0 {
		sql := "INSERT INTO `article` (`active`, `title`, `content`, `create_date`, `update_date`, `category_id`) VALUES (?, ?, ?, ?, ?, ?)"
		result, err := theDb.Exec(sql, this.Active, this.Title, this.Content, this.CreateDate.Format("2006-01-02 15:04:05"), this.UpdateDate.Format("2006-01-02 15:04:05"), this.CategoryId)
		if err != nil {
			return err
		}
		lastId, err := result.LastInsertId()
		if err != nil {
			return err
		}
		this.Id = lastId
	} else {
		sql := "UPDATE `article` SET `active` = ?, `title` = ?, `content` = ?, `create_date` = ?, `update_date` = ?, `category_id` = ? WHERE `id` = ?"
		result, err := theDb.Exec(sql, this.Active, this.Title, this.Content, this.CreateDate.Format("2006-01-02 15:04:05"), this.UpdateDate.Format("2006-01-02 15:04:05"), this.CategoryId, this.Id)
		if err != nil {
			return err
		}
		affected, err := result.RowsAffected()
		if err != nil {
			return err
		} else if affected != 1 {
			return fmt.Errorf("Wrong number of rows affected. Expected 1. Got %d", affected)
		}
	}
	return nil
}

// table category
type Category struct {
	Id   int64
	Name string
}

// Scan Category from rows object
func (this *Category) scan(rows scannable) error {
	return rows.Scan(&this.Id, &this.Name)
}

// find Category
func FindCategory(query interface{}, params ...interface{}) (*Category, error) {
	var sql = "SELECT `category`.* FROM `category`"
	// decode the query part
	switch val := query.(type) {
	case int:
		sql += " WHERE `category`.`id` = " + strconv.Itoa(val)
	case string:
		sql += " " + val
	default:
		return nil, errors.New("Unsupported type")
	}
	// process
	entity := &Category{}
	if err := entity.scan(theDb.QueryRow(sql, params...)); err != nil {
		return nil, err
	}
	return entity, nil
}

// find all Categories
func FindCategories(params ...interface{}) ([]*Category, error) {
	sql := "SELECT `category`.* FROM `category`"
	// first param might be extra sql. Rest are parameters
	if len(params) > 0 {
		value := params[0]
		params = params[1:]
		query, ok := value.(string)
		if !ok {
			errors.New("Not supported query type")
		}
		sql += " " + query
	}
	// execute the query
	rows, err := theDb.Query(sql, params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	// process rows
	var entities []*Category
	for rows.Next() {
		entity := &Category{}
		if err := entity.scan(rows); err != nil {
			return nil, err
		}
		entities = append(entities, entity)
	}
	return entities, nil
}

// Save Category
func (this *Category) Save() error {
	// update or insert?
	if this.Id == 0 {
		sql := "INSERT INTO `category` (`name`) VALUES (?)"
		result, err := theDb.Exec(sql, this.Name)
		if err != nil {
			return err
		}
		lastId, err := result.LastInsertId()
		if err != nil {
			return err
		}
		this.Id = lastId
	} else {
		sql := "UPDATE `category` SET `name` = ? WHERE `id` = ?"
		result, err := theDb.Exec(sql, this.Name, this.Id)
		if err != nil {
			return err
		}
		affected, err := result.RowsAffected()
		if err != nil {
			return err
		} else if affected != 1 {
			return fmt.Errorf("Wrong number of rows affected. Expected 1. Got %d", affected)
		}
	}
	return nil
}
